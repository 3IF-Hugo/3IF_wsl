#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <unistd.h>
#include <sys/mman.h>

#include "mem.h"

void * heap_base = NULL;// first address of the heap
void * heap_end  = NULL;// first address beyond the heap

int mem_initialized = 0;

// initialize the memory manager
//version avec boundary flags
void mem_init(void)
{
    // request memory from the kernel
    heap_base = mmap(NULL, 800, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
    assert(heap_base != MAP_FAILED);

    heap_end = heap_base + 800 ;

    // create one big free block
    void *block_ptr = heap_base;
    *( (int64_t*)block_ptr ) = 800;

    // set the boundary flags
    void *boundary_ptr = block_ptr + 800 - 8;
    *( (int64_t*)(boundary_ptr)) = 800;
    
    mem_initialized = 1;
}
// Initialization des blocs avant ex.4
// void mem_init(void)
// {
//     // request memory from the kernel
//     heap_base = mmap(NULL, 800, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
//     assert(heap_base != MAP_FAILED);

//     heap_end = heap_base + 800 ;

//     // create some free blocks: five of 80 bytes and one of 400 bytes
//     void *block_ptr;
//     for(int i=0; i<5;i++)
//     {
//         block_ptr = heap_base + 80*i;
//         *( (int64_t*)block_ptr ) = 80; // this is the header
//     }
//     block_ptr = heap_base + 400;
//     *( (int64_t*)block_ptr ) = 400;
    
//     mem_initialized = 1;
// }

void * mem_alloc(int64_t length)
{
    assert(mem_initialized == 1);
    
    // compute actual size of block
    length = (length+15)/16*16 ; // round up to nearest multiple of 8, e.g. 42 -> 48
    length += 16;              // add space for the header e.g. 56

    // heap traversal
    void *  block_ptr ;
    int64_t header ;
    int64_t size;
    int64_t boundary_flag;   
    char    flags;
    
    block_ptr = heap_base;
    while(block_ptr < heap_end)
    {
        header = *( (int64_t*)block_ptr );
        flags  = header & 0b111;  // keep only three least significant bits
        size = header & ~0b111;   // discard the three least significant bits
        boundary_flag = *( (int64_t*)(block_ptr + size - 8) );

        if( (flags == 0 ) &&      // if current block is free, and
            (size >= length)){     // is also large enough, then we have a winner
            if (size > length){
                void * block_ptr_decoupe = block_ptr + length;
                *( (int64_t*)block_ptr_decoupe ) = size - length;
                size = length;
            }
            break;
        }

        // otherwise we move on to the next block
        block_ptr += size;
    }

    // if the heap  traversal reached this far, then it  means we have
    // found no suitable block, so we should return NULL
    if(block_ptr >= heap_end)
    {
        return NULL;
    }

    flags = 0b001; // mark block as taken
    header = size | flags; //concaténer size et flags
    boundary_flag = header;
    *( (int64_t*)block_ptr ) = header ; // write header back into the block
    *( (int64_t*)(block_ptr + size - 8) ) = boundary_flag; // write boundary flag back into the block

    return block_ptr + 8 ; // skip header
}

// mem alloc sans les boundary flags
// void * mem_alloc(int64_t length)
// {
//     assert(mem_initialized == 1);
    
//     // compute actual size of block
//     length = (length+7)/8*8 ; // round up to nearest multiple of 8, e.g. 42 -> 48
//     length += 8;              // add space for the header e.g. 56

//     // heap traversal
//     void *  block_ptr ;
//     int64_t header ;
//     int64_t size;   
//     char    flags;
    
//     block_ptr = heap_base;
//     while(block_ptr < heap_end)
//     {
//         header = *( (int64_t*)block_ptr );
//         flags  = header & 0b111;  // keep only three least significant bits
//         size = header & ~0b111;   // discard the three least significant bits

//         if( (flags == 0 ) &&      // if current block is free, and
//             (size >= length)){     // is also large enough, then we have a winner
//             if (size > length){
//                 void * block_ptr_decoupe = block_ptr + length;
//                 *( (int64_t*)block_ptr_decoupe ) = size - length;
//                 size = length;
//             }
//             break;
//         }

//         // otherwise we move on to the next block
//         block_ptr += size;
//     }

//     // if the heap  traversal reached this far, then it  means we have
//     // found no suitable block, so we should return NULL
//     if(block_ptr >= heap_end)
//     {
//         return NULL;
//     }

//     flags = 0b001; // mark block as taken
//     header = size | flags; //concaténer size et flags
//     *( (int64_t*)block_ptr ) = header ; // write header back into the block

//     return block_ptr + 8 ; // skip header
// }

void mem_release(void *ptr)
{
    assert( mem_initialized == 1);
    assert( ((int64_t)ptr % 8) == 0 ); // sanity check

    // deallocation algorithm
    void * block_ptr = ptr - 8; // go back to the header
    int64_t header = *( (int64_t*)block_ptr );
    int64_t size = header & ~0b111; // keep only the size
    int64_t flags = header & 0b111; // keep only the flags
    flags = 0b000; // mark block as free
    header = size | flags; // concaténer size et flags
    *( (int64_t*)block_ptr ) = header ; // write header back into the block
    *( (int64_t*)(block_ptr + size - 8) ) = header; // write boundary flag back into the block

    return;
}

void mem_show_heap(void)
{
    assert( mem_initialized == 1);
    
    void * block_ptr = heap_base;

    printf("heap_base = %p\n",heap_base);
    while(block_ptr < heap_end)
    {
        int64_t header = *( (int64_t*)block_ptr );
        char    flags  = header & 0b111;  //   keep only three least significant bits
        int64_t size   = header & ~0b111; // discard the three least significant bits
        int64_t footer = *( (int64_t*)(block_ptr + size - 8) );
        if( (size < 16) ||
            (size%16 != 0) )
        {
            printf("error: block at %p has incorrect size %ld\n",block_ptr,size);
            exit(1);
        }

        printf("  block at %p: header=0x%08lx size=%ld flags=%d (%s), footer=%ld\n",
               block_ptr,header,size,flags,
               (flags ? "taken" : "free"), footer
               );

        block_ptr += size; // move on to next block
    }

    printf("heap_end = %p\n",heap_end);

    //sanity check: a full heap traversal should reach *exactly* the end
    assert( block_ptr == heap_end); 
}

// sans les boundary flags
// void mem_show_heap(void)
// {
//     assert( mem_initialized == 1);
    
//     void * block_ptr = heap_base;

//     printf("heap_base = %p\n",heap_base);
//     while(block_ptr < heap_end)
//     {
//         int64_t header = *( (int64_t*)block_ptr );
//         char    flags  = header & 0b111;  //   keep only three least significant bits
//         int64_t size   = header & ~0b111; // discard the three least significant bits
//         int64_t footer = *( (int64_t*)(block_ptr + size - 8) );
//         if( (size < 8) ||
//             (size%8 != 0) )
//         {
//             printf("error: block at %p has incorrect size %ld\n",block_ptr,size);
//             exit(1);
//         }

//         printf("  block at %p: header=0x%08lx size=%ld flags=%d (%s), footer=%ld\n",
//                block_ptr,header,size,flags,
//                (flags ? "taken" : "free"), footer
//                );

//         block_ptr += size; // move on to next block
//     }

//     printf("heap_end = %p\n",heap_end);

//     //sanity check: a full heap traversal should reach *exactly* the end
//     assert( block_ptr == heap_end); 
// }
