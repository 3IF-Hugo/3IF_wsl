#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

#include "mem.h"

int main(int argc, char *argv[])
{
    // initialize the allocator
    mem_init();
    mem_show_heap();
    
    //Vérifiez que vous pouvez allouer successivement six blocs de petite taille, par exemple 42 octets
    char *p = mem_alloc( 42 );
    char *p2 = mem_alloc( 42 );
    char *p3 = mem_alloc( 42 );
    char *p4 = mem_alloc( 42 );
    char *p5 = mem_alloc( 42 );
    char *p6 = mem_alloc( 42 ); 
    assert( p != NULL ); // check whether the allocation was successful
    assert( p2 != NULL );
    assert( p3 != NULL );
    assert( p4 != NULL );
    assert( p5 != NULL );
    assert( p6 != NULL );
    
//     Vérifiez que vous ne pouvez pas allouer un septième bloc : il n’y a plus de blocs libres et
// l’allocateur doit renvoyer NULL.
    //mem_release(p6);
    char *p7 = mem_alloc( 42 );
    assert( p7 != NULL );
    mem_show_heap();

    mem_init();
//     Vérifiez que les tailles sont traitées correctement : une allocation de 200 doit aller dans le bloc
// libre de 400. Et une seconde allocation de 200 doit échouer.
    char *p8 = mem_alloc( 200 );
    assert( p8 != NULL );
    //mem_release( p8 );
    char *p9 = mem_alloc( 200 );
    assert( p9 != NULL ); //main: main.c:38: main: Assertion `p9 != NULL' failed.Aborted
    mem_show_heap();

    // Vérifiez que vous pouvez allouer 200, puis les désallouer, puis redemander 300 avec succès.
    mem_init();
    char *p10 = mem_alloc( 200 );
    assert( p10 != NULL );
    mem_release( p10 );
    mem_show_heap();
    // char *p11 = mem_alloc( 300 );   // Does not work anymore, as the 400 block is already cut into 2 (208 & 192). (even after mem_release)
    //                                 // Therefore, there are no blocks bigger than 300 to allocate p11.
    // assert( p11 != NULL );

    //test d'une taille de 73
    mem_init();
    char *p12 = mem_alloc( 73 );
    assert( p12 != NULL );

    printf("allocated 42 bytes at %p\n", p8);
    mem_show_heap();
}
