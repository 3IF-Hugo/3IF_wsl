#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>

#include "bag.h"


// shared variables
int sum;
bag_t *bag;
sem_t *S1;
sem_t *S2;

// each consumer thread runs this function
void *consumer(void *arg)
{
    int cnum=*(int*)arg;
    printf("consumer %d: start\n",cnum);
   
    while(1)
    {
        int *box = bb_take(bag);
        if(box==NULL)
        {
            printf("consumer %d: end\n",cnum);
            break;
        }
        //assert( box != NULL );

        sem_wait(S1);
        sum = sum + *box;
        sem_post(S1);
        
        free(box);
    }

    printf("consumer %d: end\n",cnum);
    return NULL; // dummy return to comply with required signature
}

// each producer thread runs this function
void *producer(void *arg)
{
    int pnum=*(int*)arg;
    printf("producer %d:start \n",pnum);

    int k;
    for( k = 0 ; k < pnum+1 ; k++)
    {
        int *box = malloc(sizeof(int));
        assert( box != NULL ); 
        *box = 1;

        bb_add(bag, box);
    }
    
    printf("producer %d:end\n",pnum);
    return NULL; // dummy return to comply with required signature
}

int main(int argc, char ** argv)
{
    assert(argc == 3);

    int N = atoi( argv[1] );
    assert( N > 0);

    pthread_t prod[N];
    pthread_t cons[N];

    int S = atoi( argv[2] );
    assert( S > 0 );
    
    S1=malloc(sizeof(sem_t));
    assert(S1 != NULL);
    sem_init(S1,0,1);
    
    // initialize shared variables
    bag=bb_create(S); 
    assert(bag != NULL);
    sum=0;

    int r;
    

    for(int pnum = 0 ; pnum < N ; pnum++)
    {
        int *thread_arg=malloc(sizeof(int));
        *thread_arg = pnum;
        r=pthread_create(&prod[pnum], NULL, producer,thread_arg);
        if ( r )
        {
            printf("error: could not spawn producer %d\n",pnum);
            exit(1);
        }
    }

    for(int cnum = 0 ; cnum < N ; cnum++)
    {
        int *thread_arg=malloc(sizeof(int));
        *thread_arg = cnum;
        r=pthread_create(&cons[cnum],NULL, consumer, thread_arg);
        if ( r )
        {
            printf("error: could not spawn consumer %d\n",cnum);
            exit(1);
        }
    }

    //wait for all producers to finish
    for(int pnum = 0 ; pnum < N ; pnum++)
    {
        r=pthread_join(prod[pnum], NULL);
        if ( r )
        {
            printf("error: could not join producer %d\n",pnum);
            exit(1);
        }
    }

    //close the bag
    bb_close(bag,N);
    
    //wait for all consumers to finish
    for(int cnum = 0 ; cnum < N ; cnum++)
    {
        r=pthread_join(cons[cnum], NULL);
        if ( r )
        {
            printf("error: could not join consumer %d\n",cnum);
            exit(1);
        }
    }
    //sleep(2);
    
    printf("theroretical result=%d\n",N*(N+1)/2);
    sem_wait(S1);
    printf("actual computed sum=%d\n", sum);
    sem_post(S1);
    return 0;
}
