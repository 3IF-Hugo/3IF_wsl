#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <semaphore.h>
#include <pthread.h>
#include <unistd.h>

#include "bag.h"

bag_t * bb_create(int size)
{
    assert(size > 0);
    
    bag_t *bag=malloc(sizeof(bag_t));
    assert(bag != NULL);

    //init S1 - mutex pour ne permet pas de 2 producteur faire add en meme temps
    bag->S1=malloc(sizeof(sem_t));
    assert(bag->S1 != NULL);
    sem_init(bag->S1,0,1);

    //init S2 - pour bloque add dans le cas pleine
    bag->S2=malloc(sizeof(sem_t));
    assert(bag->S2 != NULL);
    sem_init(bag->S2,0,size);

    //init S3 - pour blocque take dans le cas vide
    bag->S3=malloc(sizeof(sem_t));
    assert(bag->S3 != NULL);
    sem_init(bag->S3,0,0);

    bag->elem = malloc( size * sizeof(void*));
    assert(bag->elem != NULL);

    bag->size  = size;
    bag->count = 0;         // 'count' == index of first free slot in 'elem'
    bag->is_closed = 0;

    return bag;
}

void bb_add(bag_t * bag, void * element)
{
    assert(bag != NULL);                 // sanity check
    
    //add signalisation S2
    sem_wait(bag->S2);
    //while( bag->count >= bag->size ) { } // CAUTION: this synchronization is bogus
    sem_wait(bag->S1);
    assert( bag-> is_closed == 0 );   // adding to a closed bag is an error
    assert( bag->count < bag->size ); // sanity check

    bag->elem[bag->count] = element;
    bag->count += 1;
    
    sem_post(bag->S1);
    sem_post(bag->S3);
}

void * bb_take(bag_t *bag)
{
    
    assert(bag != NULL); // sanity check

    //add signalisation S3
    sem_wait(bag->S3);

    //add synchronisation with S1
    sem_wait(bag->S1);
    //while( bag->count <= 0 ) { } // CAUTION: this synchronization is bogus
    
    if( bag->count == 0 && bag->is_closed == 1){
        sem_post(bag->S1);
        return NULL;
    }
    assert (bag->count > 0); // sanity check

    bag->count -= 1;
    void *r = bag->elem[bag->count];
    bag->elem[bag->count] = NULL;
    
    sem_post(bag->S1);
    sem_post(bag->S2);
    
    usleep(10);// artificial delay to increase the occurence of race conditions
    return r;
}

void bb_close(bag_t *bag, int N)
{
    assert(bag->is_closed == 0);
    bag->is_closed = 1;
    
    //wake up all the threads in bb_take
    for(int i=0; i<N; i++)
    {
        sem_post(bag->S3);
    }
}